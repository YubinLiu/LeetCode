## 字符串搜索算法

LeetCode 中的第 28 个问题 —— “Implement strStr()”，当时只是草草调用了 Java API 中的indexOf() 以及写了两个for循环的方法来实现，意义不大。于是学习了Boyer Moore算法（当然还有别的一些字符串搜索算法，待日后如果学习会继续添加进来）。

参考如下：
1. http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html
2. https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm

### 问题
实现函数：<br>
int strStr(String haystack, String needle) <br>
若 needle 存在于 haystack 中，返回其第一次出现的位置，否则返回 -1。<br>
(注：find a needle in a haystack —— 大海捞针)。

#### Boyer Moore算法
* 思想：<br>
对于每一次失败的匹配尝试，算法都能够利用这些信息来排除尽可能多的无法匹配的位置。
* 算法解释：<br>
将字符串与搜索词头部对齐，从尾部开始比较。<br>
核心：坏字符规则、好后缀规则。
```
坏字符规则：坏字符，即不匹配的字符。根据坏字符是否在搜索词中，可分为两种情况。
1 不在搜索词中：可直接将搜索词向后移动到坏字符后一位。
2 在搜索词中：在搜索词中，找到离当前位置最近的那个坏字符，将其与字符串的坏字符对齐。
规则： 后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置。
若不在搜索词中，上一次出现位置为 -1。
```
```
好后缀规则：好后缀，即所有尾部匹配的字符串。如 ASIMPLE 和 EXAMPLE，头部对齐，从尾部开始比较，那么 "E"、"LE"、"PLE"、"MPLE" 均为好后缀。
规则：后移位数 = 好后缀的位置 - 搜索词中上一次出现的位置。
注意：
1 好后缀的位置以最后一个字符为准。如 "ABCDEF" 的 "EF" 是好后缀，那么以 "F" 为准，好后缀的位置为 5（从 0 开始计算）。
2 若好后缀在搜索词中只出现一次，则它上一次出现的位置为 -1。
3 若好后缀有多个，则除最长的好后缀外，其他好后缀上一次出现位置必须在头部。如 "BABCDAB" 的好后缀为 "DAB"、"AB"、"B"，那么采用的好后缀为 "B"，上一次出现位置在开头，即第 0 位。
```
选取上述两种规则获取到的后移位数中的较大值。后移位数只与搜索词有关，与原字符串无关，可预先生成 坏字符规则表 和 好后缀规则表。

* 实现：<br>
参考 wiki 中的 Java 代码，编写了一个含有坏字符以及好后缀规则的算法，详见 BoyerMoore.java。<br>
但由于好后缀规则在现实中用到的较少，所以编写了一个简化版的，只有坏字符规则的算法。详见 HorSpool.java。
